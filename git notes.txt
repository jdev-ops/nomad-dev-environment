8. Recovering from Mistakes

# You can unstage files from the index using:

git reset HEAD -- path/to/file

git reset HEAD -- .


Remove commits
git reset --hard HEAD^

undo the commit	and retain the changes introduced in the working tree
git reset --mixed HEAD^

undo the commit	and retain the changes introduced in the index
git reset --soft HEAD^

Undo a merge
git reset --merge ORIG_HEAD

Redo – recreate	the latest commit with new changes
git commit --amend

Revert – undo the changes introduced by a commit
git revert 9c7532f

How do I discard changes in my working copy that are not in the index?

For a specific file use:

git checkout path/to/file/to/revert

For all unstaged files use:

git clean -dff
git checkout -- .

or this which checks out all files from the index, overwriting working tree files.

git checkout-index -a -f


.. Extras

To remove a local branch from your machine:

git branch -d the_local_branch

To remove a remote branch from the server:

git push origin :the_remote_branch



How do you create a remote Git branch?


push the branch to the remote repository origin and tracks it

First, you create your branch locally:

git checkout -b your_branch

git push -u origin your_branch

!!!Or in Git 2.x!!!

git push -u


Team mates can reach your branch, by doing:

git fetch
git checkout origin/your_branch


Tags

Use git tag command to add a new one:
git tag -a v1.4

 -m 'version 1.4'

Tagging Later
git tag -a v1.2 9fceb02

Removing a Tag

For example, if you have created a tag called release01 in a Git repository you would remove it from your repository by doing the following:

git tag -d release01 
git push origin :refs/tags/release01 


- We use the Git command am to apply the patches; am is short for apply from mailbox

git am latest-commit/0001-Calculate-pi-with-more-digits.patch


Show branch hierarchy on the command line?

git log --all --graph --decorate --oneline --simplify-by-decoration

# Listar los commits de mezcla!

git log 678ba..master --ancestry-path --merges


Buscar cambios

git log -S'"title": "Profile Picture"'

With the -S<string> option, Git will look for differences that introduce or remove an instance of a given string.

To show differences for all the files, and not only those diffs where the change in number occurred, you need to use the --pickaxe-all option


How to diff the same file between two different commits

git diff 97cb594 HEAD -- catalog/models.py


You can also compare two files in two different revisions, like this:

git diff <revision_1>:<file_1> <revision_2>:<file_2>
git difftool revision_1:file_1 revision_2:file_2

Delete branch

git branch -d branch_name

git push origin :<branch_name>

Then you should execute this on other machines

git fetch --all --prune
or
git remote update --prune

to propagate changes.



# add a submodule

git submodule add git@gitlab.com:jalbertcruz/oriongs-lib.git main/lib

# update submodules
git submodule update --remote
git submodule foreach --recursive 'git submodule update --remote'

git clone --recursive git@gitlab.com:jalbertcruz/oriongs.git

git clone --recursive https://gitlab.com/jalbertcruz/oriongs.git

#Git update submodule recursive
git submodule update --init --recursive

git submodule foreach 'git pull origin master'





# Aumentar el buffer para hacer push de muchos ficheros
git config http.postBuffer 524288000

# Reescribir el autor de los commits
git filter-branch --env-filter '
                           GIT_AUTHOR_NAME="john Do"
                           export GIT_AUTHOR_NAME                   
                           GIT_COMMITTER_NAME="john Do"
                           export GIT_COMMITTER_NAME

                           GIT_AUTHOR_EMAIL=john@example.com
                           export GIT_AUTHOR_EMAIL                   
                           GIT_COMMITTER_EMAIL=john@example.com
                           export GIT_COMMITTER_EMAIL
                               ' -- --all
                               
                               
# stash
# To view the content of the most recent stash, run
$ git stash show -p

# To view the content of an arbitrary stash, run something like
$ git stash show -p stash@{1}


sudo apt-add-repository ppa:git-core/ppa
sudo apt-get update
sudo apt-get install git

# Can I store the .git folder outside the files I want tracked?
https://stackoverflow.com/questions/505467/can-i-store-the-git-folder-outside-the-files-i-want-tracked

You just need to ensure that the repository knows where the work tree is and vice versa.
To let the repository know where the work tree is, set the configuration value core.worktree. To let the work tree know where it's git directory is, add a file named .git (not a folder!) and add a line like
gitdir: /path/to/repo.git
Since git 1.7.5 the init command learned an extra option for this.
You can initialize a new separate repository with
git init --separate-git-dir /path/to/repo.git

# Show a word diff, using the <mode> to delimit changed words.

git diff --word-diff=color b.diff c.diff

# How to find/identify large files/commits in Git history?
https://stackoverflow.com/questions/10622179/how-to-find-identify-large-files-commits-in-git-history/42544963

git rev-list --objects --all \
| git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' \
| sed -n 's/^blob //p' \
| sort --numeric-sort --key=2 \
| cut -c 1-12,41- \
| $(command -v gnumfmt || echo numfmt) --field=2 --to=iec-i --suffix=B --padding=7 --round=nearest

# the 10 largest files in the repository
git rev-list --objects --all \
  | grep "$(git verify-pack -v .git/objects/pack/*.idx \
  | sort -k 3 -n \
  | tail -10 \
  | awk '{print$1}')"


git diff-tree --no-commit-id --name-only -r 22a6bc6638fa5b281462830434801e74b682964a

index.html
javascript/application.js
javascript/ie6.js
Another Way (less preferred for scripts, because it's a porcelain command; meant to be user-facing)

$ git show --pretty="" --name-only 57d2f55a2075a3a32ddaf0879b5110e64e64957e
index.html
javascript/application.js
javascript/ie6.js
The --no-commit-id suppresses the commit ID output.
The --pretty argument specifies an empty format string to avoid the cruft at the beginning.
The --name-only argument shows only the file names that were affected.
The -r argument is to recurse into sub-trees


Find all files modified between commits in Git

$ git diff --name-only <SHA, tag start> <SHA, tag end>
$ git diff --name-status <SHA, tag start> <SHA, tag end>

| numfmt --field=2 --to=iec-i --suffix=B --padding=7 --round=nearest

Try this if you don't want any of the merges listed in git status:

$ git reset --merge

git commit --allow-empty -m "Initial commit"
git co -b dev

# submodules

git submodule add git@github.com:polyglot-concurrency/erlang_chat_lib.git apps/chat_client/src/lib --branch dev
git submodule add git@github.com:polyglot-concurrency/erlang_chat_lib.git apps/chat_server/src/lib --branch dev


git stash show -p "stash@{4}"
git stash apply "stash@{4}"

# diff file visualizer
# https://diff2html.xyz/
diff2html -i file -- a01.diff


## How to list all the files in a commit?

$ git diff-tree --no-commit-id --name-only -r 57d2f55a2075a3a32ddaf0879b5110e64e64957e
index.html
javascript/application.js
javascript/ie6.js
Another Way (less preferred for scripts, because it's a porcelain command; meant to be user-facing)

$ git show --pretty="" --name-only 57d2f55a2075a3a32ddaf0879b5110e64e64957e    
index.html
javascript/application.js
javascript/ie6.js
The --no-commit-id suppresses the commit ID output.
The --pretty argument specifies an empty format string to avoid the cruft at the beginning.
The --name-only argument shows only the file names that were affected.
The -r argument is to recurse into sub-trees


## Find all files modified between commits in Git

$ git diff --name-only <SHA, tag start> <SHA, tag end>
$ git diff --name-status <SHA, tag start> <SHA, tag end>

# A cheat sheet to making a new release:
$ git commit -m "New things" && git push
$ git tag -a v0.0.3 -m "v0.0.3"
$ git push --tags


git fetch origin
git rebase origin/master


# gpg

# https://help.github.com/en/articles/generating-a-new-gpg-key
$ gpg --full-generate-key


# gpg remove passphrase
$ gpg --edit-key <yourkeyhere>
> passwd

When GnuPG prompts for the new passphrase, just leave it blank and hit enter.

# https://help.github.com/en/articles/telling-git-about-your-signing-key

$ gpg --list-secret-keys --keyid-format LONG

--------------------------
sec   rsa4096/0898C59143E8F96D 2019-04-18 [SC]
      A29AB475A4F3B49CBE720EAE0898C59143E8F96D
uid                 [ultimate] José Albert Cruz Almaguer <jalbertcruz@gmail.com>
ssb   rsa4096/02C427EB1287F24F 2019-04-18 [E]

$ gpg --armor --export 0898C59143E8F96D
Copy your GPG key, beginning with 
-----BEGIN PGP PUBLIC KEY BLOCK-----
and ending with 
-----END PGP PUBLIC KEY BLOCK-----

$ git config --global user.signingkey 0898C59143E8F96D

# https://help.github.com/en/articles/signing-commits
$ git commit -S -m "your commit message"
# Creates a signed commit

# https://help.github.com/en/articles/signing-tags
$ git tag -s mytag
# Creates a signed tag
$ git tag -v mytag
# Verifies the signed tag

# Encryption
gpg --recipient user@gmail.com --encrypt g.txt
# Decryption
gpg --recipient user@gmail.com -o g.txt -d g.txt.gpg

# will commit all tracked files, not track untracked files
git commit -a --no-edit --amend